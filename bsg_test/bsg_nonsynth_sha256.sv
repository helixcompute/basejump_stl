//
// author: mbt + AI Generated by ChatGPT o1 using this prompt:
//
// "generate systemverilog function that implements sha256 on an input string"
//
// fix syntax errors about variable declaration
// fix list of constants (from wikipedia)
//

    // ---------------------------------------------------------
    // Local function for right-rotate
    // ---------------------------------------------------------
    function automatic logic [31:0] bsg_nonsynth_sha256_rotr(input logic [31:0] x, input int n);
       bsg_nonsynth_sha256_rotr = (x >> n) | (x << (32 - n));
    endfunction


function automatic logic [255:0] bsg_nonsynth_sha256(input string message);
    // ---------------------------------------------------------
    // SHA-256 constants
    // ---------------------------------------------------------
    // Initial hash values (H0..H7)
    logic [31:0] H0 = 32'h6a09e667;
    logic [31:0] H1 = 32'hbb67ae85;
    logic [31:0] H2 = 32'h3c6ef372;
    logic [31:0] H3 = 32'ha54ff53a;
    logic [31:0] H4 = 32'h510e527f;
    logic [31:0] H5 = 32'h9b05688c;
    logic [31:0] H6 = 32'h1f83d9ab;
    logic [31:0] H7 = 32'h5be0cd19;

   logic [63:0]  bitLen;
   int 		 numChunks;

    // Temporary variables for each chunk
    logic [31:0] w [0:63];  // message schedule array
    logic [31:0] a, b, c, d, e, f, g, h;
    logic [31:0] T1, T2;
    logic [31:0] S0;
    logic [31:0] maj;
   
   
    // Process each 64-byte chunk
    int chunkIdx;
   
    // Round constants K
    logic [31:0] K [0:63] = '{
			      32'h428a2f98, 32'h71374491, 32'hb5c0fbcf, 32'he9b5dba5, 32'h3956c25b, 32'h59f111f1, 32'h923f82a4, 32'hab1c5ed5,
			      32'hd807aa98, 32'h12835b01, 32'h243185be, 32'h550c7dc3, 32'h72be5d74, 32'h80deb1fe, 32'h9bdc06a7, 32'hc19bf174,
			      32'he49b69c1, 32'hefbe4786, 32'h0fc19dc6, 32'h240ca1cc, 32'h2de92c6f, 32'h4a7484aa, 32'h5cb0a9dc, 32'h76f988da,
			      32'h983e5152, 32'ha831c66d, 32'hb00327c8, 32'hbf597fc7, 32'hc6e00bf3, 32'hd5a79147, 32'h06ca6351, 32'h14292967,
			      32'h27b70a85, 32'h2e1b2138, 32'h4d2c6dfc, 32'h53380d13, 32'h650a7354, 32'h766a0abb, 32'h81c2c92e, 32'h92722c85,
			      32'ha2bfe8a1, 32'ha81a664b, 32'hc24b8b70, 32'hc76c51a3, 32'hd192e819, 32'hd6990624, 32'hf40e3585, 32'h106aa070,
			      32'h19a4c116, 32'h1e376c08, 32'h2748774c, 32'h34b0bcb5, 32'h391c0cb3, 32'h4ed8aa4a, 32'h5b9cca4f, 32'h682e6ff3,
			      32'h748f82ee, 32'h78a5636f, 32'h84c87814, 32'h8cc70208, 32'h90befffa, 32'ha4506ceb, 32'hbef9a3f7, 32'hc67178f2			     
			      };

    // ---------------------------------------------------------
    // Convert string to array of bytes
    // ---------------------------------------------------------
    // We'll accumulate the raw bytes into a local queue for padding
    byte dataQueue[$];
    int i;
    for (i = 0; i < message.len(); i++) begin
        dataQueue.push_back(message[i]);
    end

    // ---------------------------------------------------------
    // Pad the message according to SHA-256 rules
    // 1. Append one '1' bit  => 0x80
    // 2. Append 0 <= k < 512 zero bits so that the total length
    //    (in bits) is congruent to 448 mod 512
    // 3. Append 64-bit message length (big-endian) at the end
    // ---------------------------------------------------------
    // Original message length in bits:
    bitLen = message.len() * 8;

    // 1. Append 0x80
    dataQueue.push_back(8'h80);

    // 2. Append zero bytes until (length in bits) % 512 == 448
    //    i.e. (length in bytes) % 64 == 56
    while (((dataQueue.size() * 8) % 512) != 448) begin
        dataQueue.push_back(8'h00);
    end

    // 3. Append 64-bit length (big-endian)
    //    We split bitLen (which is 64-bit) into 8 bytes
    for (int j = 7; j >= 0; j--) begin
        dataQueue.push_back((bitLen >> (8*j)) & 8'hFF);
    end

    // ---------------------------------------------------------
    // Process the message in 512-bit (64-byte) chunks
    // ---------------------------------------------------------
    numChunks = dataQueue.size() / 64;

    for (chunkIdx = 0; chunkIdx < numChunks; chunkIdx++) begin
        // -----------------------------------------------------
        // Break chunk into sixteen 32-bit big-endian words w[0..15]
        // -----------------------------------------------------
        for (int m = 0; m < 16; m++) begin
            int baseIdx = chunkIdx * 64 + m*4;
            w[m] = {
                dataQueue[baseIdx+0],
                dataQueue[baseIdx+1],
                dataQueue[baseIdx+2],
                dataQueue[baseIdx+3]
            }; // big-endian assembly
        end

        // -----------------------------------------------------
        // Extend the first 16 words into the remaining 48 words
        // -----------------------------------------------------
        for (int m = 16; m < 64; m++) begin
            logic [31:0] s0, s1;
            s0 = bsg_nonsynth_sha256_rotr(w[m-15], 7) ^ bsg_nonsynth_sha256_rotr(w[m-15],18) ^ (w[m-15] >> 3);
            s1 = bsg_nonsynth_sha256_rotr(w[m-2], 17) ^ bsg_nonsynth_sha256_rotr(w[m-2],19)  ^ (w[m-2] >> 10);
            w[m] = w[m-16] + s0 + w[m-7] + s1;
        end

        // -----------------------------------------------------
        // Initialize working variables to current hash value
        // -----------------------------------------------------
        a = H0; b = H1; c = H2; d = H3; e = H4; f = H5; g = H6; h = H7;

        // -----------------------------------------------------
        // The main 64 rounds
        // -----------------------------------------------------
        for (int t = 0; t < 64; t++) begin
            logic [31:0] S1 = (bsg_nonsynth_sha256_rotr(e,6) ^ bsg_nonsynth_sha256_rotr(e,11) ^ bsg_nonsynth_sha256_rotr(e,25));
            logic [31:0] ch = (e & f) ^ ((~e) & g);
            T1 = h + S1 + ch + K[t] + w[t];

            S0 = (bsg_nonsynth_sha256_rotr(a,2) ^ bsg_nonsynth_sha256_rotr(a,13) ^ bsg_nonsynth_sha256_rotr(a,22));
            maj = (a & b) ^ (a & c) ^ (b & c);
            T2 = S0 + maj;

            h = g;
            g = f;
            f = e;
            e = d + T1;
            d = c;
            c = b;
            b = a;
            a = T1 + T2;
        end

        // -----------------------------------------------------
        // Add the compressed chunk to the current hash value
        // -----------------------------------------------------
        H0 = H0 + a;
        H1 = H1 + b;
        H2 = H2 + c;
        H3 = H3 + d;
        H4 = H4 + e;
        H5 = H5 + f;
        H6 = H6 + g;
        H7 = H7 + h;
    end

    // ---------------------------------------------------------
    // Construct final 256-bit hash (big-endian)
    // ---------------------------------------------------------
    bsg_nonsynth_sha256 = {
        H0, H1, H2, H3, H4, H5, H6, H7
    };

endfunction
